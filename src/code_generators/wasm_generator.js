/**
 * WebAssembly code generator for BitBLT operations.
 * This generator creates WebAssembly binary directly without going through WAT.
 */
const CodeGeneratorInterface = require("./generator_interface");
const { BitBltOp } = require("../bitblt");

class WasmGenerator extends CodeGeneratorInterface {
  /**
   * Generates WebAssembly code for a BitBLT operation.
   *
   * @param {Object} params - Parameters for the BitBLT operation
   * @returns {Promise<Object>} - An object containing the generated WebAssembly module and metadata
   */
  async generateCode(params) {
    const { dst, dstX, dstY, width, height, src, srcX, srcY, op, aligned } =
      params;

    if (aligned) {
      return this._generateAlignedCode(params);
    } else {
      return this._generateStandardCode(params);
    }
  }

  /**
   * Executes the generated WebAssembly code.
   *
   * @param {Object} generatedCode - The code generated by generateCode()
   * @param {Object} dst - Destination bitmap
   * @param {Object} src - Source bitmap
   * @returns {void}
   */
  executeCode(generatedCode, dst, src) {
    // If this is a placeholder, perform the operation in JavaScript
    if (generatedCode.placeholder) {
      console.log(
        `WebAssembly execution skipped: ${
          generatedCode.message || "Placeholder"
        }`
      );

      // If we have parameters, perform the BitBLT operation in JavaScript
      if (generatedCode.params) {
        this._performBitBltInJavaScript(generatedCode, dst, src);
      }

      return;
    }

    try {
      console.log("Executing WebAssembly BitBLT COPY operation");

      // Copy source and destination data to WebAssembly memory
      const srcData = new Int32Array(
        generatedCode.memory.buffer,
        generatedCode.srcOffset,
        src.data.length
      );
      const dstData = new Int32Array(
        generatedCode.memory.buffer,
        generatedCode.dstOffset,
        dst.data.length
      );

      // Copy source data to WebAssembly memory
      srcData.set(src.data);

      // Copy destination data to WebAssembly memory
      dstData.set(dst.data);

      // Call the WebAssembly function
      if (
        generatedCode.instance &&
        generatedCode.instance.exports &&
        generatedCode.instance.exports.copy
      ) {
        generatedCode.instance.exports.copy();

        // Since our WebAssembly module is still a no-op, we'll perform the BitBLT operation in JavaScript
        // In a real implementation, this would be done by the WebAssembly module
        if (generatedCode.params) {
          this._performBitBltInJavaScript(generatedCode, dst, src);
        }
      } else {
        console.warn("WebAssembly copy function not found");
        return;
      }

      // Copy the result back to the destination bitmap
      for (let i = 0; i < dst.data.length; i++) {
        dst.data[i] = dstData[i];
      }
    } catch (error) {
      console.error("Error executing WebAssembly code:", error);
    }
  }

  /**
   * Generates WebAssembly code for standard (non-aligned) BitBLT operations.
   *
   * @param {Object} params - Parameters for the BitBLT operation
   * @returns {Promise<Object>} - An object containing the generated WebAssembly module and metadata
   * @private
   */
  async _generateStandardCode(params) {
    const { dst, dstX, dstY, width, height, src, srcX, srcY, op } = params;

    // For now, we'll only implement the COPY operation
    if (op !== BitBltOp.COPY) {
      return {
        type: "wasm",
        aligned: false,
        placeholder: true,
        message: `WebAssembly code generation for operation ${op} not yet implemented`,
      };
    }

    try {
      // Clip the operation to the bounds of both bitmaps
      const srcMaxX = Math.min(srcX + width, src.width);
      const srcMaxY = Math.min(srcY + height, src.height);
      const dstMaxX = Math.min(dstX + width, dst.width);
      const dstMaxY = Math.min(dstY + height, dst.height);

      // Calculate actual dimensions after clipping
      const actualWidth = Math.min(srcMaxX - srcX, dstMaxX - dstX);
      const actualHeight = Math.min(srcMaxY - srcY, dstMaxY - dstY);

      // Create a memory to share between JS and WASM
      const srcSize = src.data.length * 4; // 4 bytes per int
      const dstSize = dst.data.length * 4; // 4 bytes per int
      const memorySize = Math.ceil((srcSize + dstSize + 1024) / 65536); // In pages (64KB each)
      const memory = new WebAssembly.Memory({ initial: memorySize });

      // Define memory offsets
      const srcOffset = 0;
      const dstOffset = srcSize;

      // For now, we'll use a minimal WebAssembly module
      // In a real implementation, we would generate more complex code
      // that actually performs the BitBLT operation

      // For now, we'll use a simpler approach
      // Instead of generating WebAssembly binary directly, we'll create a placeholder
      // and perform the actual BitBLT operation in JavaScript

      // In a real implementation, we would generate WebAssembly binary that performs the operation
      // But for now, we'll just create a placeholder and do the work in executeCode

      // Create a placeholder
      return {
        memory,
        srcOffset,
        dstOffset,
        srcSize,
        dstSize,
        type: "wasm",
        aligned: false,
        placeholder: true,
        message: "WebAssembly binary generation not yet implemented",
        params: {
          srcX,
          srcY,
          dstX,
          dstY,
          width: actualWidth,
          height: actualHeight,
          srcIntsPerRow: src.intsPerRow,
          dstIntsPerRow: dst.intsPerRow,
        },
      };
    } catch (error) {
      console.error("Error generating WebAssembly code:", error);
      return {
        type: "wasm",
        aligned: false,
        placeholder: true,
        error: error.message,
      };
    }
  }

  /**
   * Generates WebAssembly code for aligned BitBLT operations.
   *
   * @param {Object} params - Parameters for the BitBLT operation
   * @returns {Promise<Object>} - An object containing the generated WebAssembly module and metadata
   * @private
   */
  async _generateAlignedCode(params) {
    // For now, just return a placeholder
    return {
      type: "wasm",
      aligned: true,
      placeholder: true,
      message: "WebAssembly code generation not yet implemented",
    };
  }

  /**
   * Performs a BitBLT operation in JavaScript when WebAssembly is not available.
   *
   * @param {Object} generatedCode - The generated code object
   * @param {Object} dst - Destination bitmap
   * @param {Object} src - Source bitmap
   * @private
   */
  _performBitBltInJavaScript(generatedCode, dst, src) {
    // Extract parameters
    const {
      srcX,
      srcY,
      dstX,
      dstY,
      width,
      height,
      srcIntsPerRow,
      dstIntsPerRow,
    } = generatedCode.params;

    // Create arrays to access the bitmap data
    const srcData = new Int32Array(
      generatedCode.memory.buffer,
      generatedCode.srcOffset,
      src.data.length
    );
    const dstData = new Int32Array(
      generatedCode.memory.buffer,
      generatedCode.dstOffset,
      dst.data.length
    );

    // Copy source data to WebAssembly memory
    srcData.set(src.data);

    // Copy destination data to WebAssembly memory
    dstData.set(dst.data);

    // Check if source and destination are the same bitmap and regions overlap
    const sameBuffer = src === dst;
    const overlapHorizontal =
      sameBuffer &&
      ((srcX < dstX && srcX + width > dstX) || // Source starts before dest and overlaps
        (dstX < srcX && dstX + width > srcX)); // Dest starts before source and overlaps
    const overlapVertical =
      sameBuffer &&
      ((srcY < dstY && srcY + height > dstY) || // Source starts before dest and overlaps
        (dstY < srcY && dstY + height > srcY)); // Dest starts before source and overlaps

    // Determine the direction to process pixels based on overlap
    let xStart, xEnd, xStep;
    let yStart, yEnd, yStep;

    if (overlapHorizontal && srcX < dstX) {
      // Source is to the left of destination, process right-to-left
      xStart = width - 1;
      xEnd = -1;
      xStep = -1;
    } else {
      // No horizontal overlap or source is to the right of destination, process left-to-right
      xStart = 0;
      xEnd = width;
      xStep = 1;
    }

    if (overlapVertical && srcY < dstY) {
      // Source is above destination, process bottom-to-top
      yStart = height - 1;
      yEnd = -1;
      yStep = -1;
    } else {
      // No vertical overlap or source is below destination, process top-to-bottom
      yStart = 0;
      yEnd = height;
      yStep = 1;
    }

    // Perform the BitBLT operation
    for (let y = yStart; y !== yEnd; y += yStep) {
      for (let x = xStart; x !== xEnd; x += xStep) {
        // Calculate source and destination pixel positions
        const srcPixelX = srcX + x;
        const srcPixelY = srcY + y;
        const dstPixelX = dstX + x;
        const dstPixelY = dstY + y;

        // Calculate which integers in the data arrays contain these pixels
        const srcIntIndex =
          srcPixelY * srcIntsPerRow + Math.floor(srcPixelX / 32);
        const dstIntIndex =
          dstPixelY * dstIntsPerRow + Math.floor(dstPixelX / 32);

        // Calculate which bits within those integers represent these pixels
        const srcBitIndex = 31 - (srcPixelX % 32);
        const dstBitIndex = 31 - (dstPixelX % 32);

        // Extract the source pixel value (0 or 1)
        const srcPixel = srcData[srcIntIndex] & (1 << srcBitIndex) ? 1 : 0;

        // Set or clear the destination pixel based on the source pixel
        if (srcPixel) {
          dstData[dstIntIndex] |= 1 << dstBitIndex;
        } else {
          dstData[dstIntIndex] &= ~(1 << dstBitIndex);
        }
      }
    }

    // Copy the result back to the destination bitmap
    for (let i = 0; i < dst.data.length; i++) {
      dst.data[i] = dstData[i];
    }
  }
}

module.exports = WasmGenerator;
